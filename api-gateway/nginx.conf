events { }

http {

    lua_shared_dict jwt_cache 10m;

    upstream auth {
        server auth:8000;
    }

    upstream matching-engine {
        server matching-engine:8001;

    }

    upstream transaction {
            server transaction:8002;
    }

#     upstream frontend {
#              server frontend:5173;
#     }

    server {
        listen 3001;

        location /authentication/ {
            verify_request off;
            proxy_pass http://auth/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }


        # For all locations except the authentication endpoint itself, perform authentication
        verify_request /verify;

        # Define the auth subrequest location
        location = /verify {
            internal;
            # Here you can use Lua (or even a simple proxy_pass) to validate the token.
            # For example, using Lua to check the cache and then, if needed, call the auth service:
            access_by_lua_block {
                local http = require("resty.http")
                local cache = ngx.shared.jwt_cache

                local auth_header = ngx.var.http_Authorization
                if not auth_header then
                    ngx.say("Unauthorized")
                    return ngx.exit(401)
                end

                local token = auth_header:match("Bearer%s+(.+)")
                if not token then
                    ngx.say("Token Required.")
                    return ngx.exit(401)
                end

                local cached = cache:get(token)
                if cached then
                    ngx.req.set_header("X-User-Data", cached)
                    return ngx.exit(200)
                else
                    local httpc = http.new()
                    local res, err = httpc:request_uri("http://auth:8000/validate_token", {
                        method = "GET",
                        headers = { ["Authorization"] = "Bearer " .. token },
                        ssl_verify = false,
                    })
                    if not res or res.status ~= 200 then
                        ngx.say("Token Validation failed")
                        return ngx.exit(401)
                    end

                    local cjson = require("cjson.safe")
                    local data = cjson.decode(res.body)
                    if not data or not data.username or not data.id then
                        ngx.say("Missing Data in token")
                        return ngx.exit(401)
                    end

                    local userdata = data.username .. "|" .. data.id
                    cache:set(token, userdata, 300)
                    ngx.req.set_header("X-User-Data", userdata)
                    return ngx.exit(200)
                end
            }
        };


        location /engine/ {
            proxy_pass http://matching-engine/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /transaction/ {
            proxy_pass http://transaction/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /setup/ {
            proxy_pass http://transaction/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

#         location /frontend/ {
#             proxy_pass http://frontend/;
#             proxy_set_header Host $host;
#             proxy_set_header X-Real-IP $remote_addr;
#             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#             proxy_set_header X-Forwarded-Proto $scheme;
#         }
    }
}
